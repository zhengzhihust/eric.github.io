---
layout: post
title:  "《Redis设计与实现》读书笔记"
date:   2016-03-27 22:39:00 +0800
categories: jekyll update
group: navigation
tags: Java
---

### 准备：

Redis环境配置：http://www.cnblogs.com/linjiqin/archive/2013/05/27/3101694.html

Redis AOF功能：http://blog.csdn.net/blueheart20/article/details/26520823

### 一、简单动态字符串（SDS）

#### 1.空间预分配：减少连续执行字符串增长操作所需的内存重分配次数

如果对SDS进行修改之后，SDS的长度（也就是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS的len属性的值和free的属性的值相同，SDS的buf数组的实际长度=len_before * 2 + 1 bytes。

如果SDS进行修改之后，SDS的长度超过1MB，那么程序会分配1MB的未使用空间，SDS的buf数组的实际长度=n*1MB+1MB + 1byte。

#### 2.SDS的API都是二进制安全的，可以保存任意格式的二进制数据。

#### 3.字典：当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。

Redis的哈希表采用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。

扩展和收缩哈希表是通过rehash（重新散列）操作的，这个操作是渐进式的，因为rehash会对服务器性能造成影响。

#### 4.跳跃表：跳跃表是有序集合的底层实现之一，Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表的信息（比如表头结点、表尾结点、长度），而zskiplistNode则用于表示跳跃表节点。

#### 5.整数集合：是集合键的底层实现之一，底层实现为数组，这个数组以有序、无重复的方式保存集合元素。升级操作是当一个新元素添加到整数集合里面且新元素的类型比整数集合现有所有的类型都要长时的操作，这为整数集合带来了操作上的灵活性，并且尽可能的解决了内存。整数集合只支持升级操作，不支持降级操作。

#### 6.压缩列表：一种为节约内存而开发的顺序型数据结构，被用作列表键和哈希键的底层实现之一，可以包含多个节点，每个节点可以保存一个字节数组或整数值。

#### 7.对象：Redis共有字符串、列表、哈希、集合、有序集合5种类型的对象。Redis在对象的内存回收时，采用自己建立的引用技术技术实现内存回收机制，当对象的引用计数值为0时，对象所占用的内存会被释放。redis的对象共享只对包含整数值的字符串对象进行共享。对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时长。

### 二、单机数据库的实现

#### 1.过期键的删除策略：

定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。

惰性删除：放任键过期不管，每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键。

定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。

当主服务器删除一个过期键之后，它回想所有从服务器发送一条DEL命令，显示的删除过期键。从服务器接收主节点发来的DEL命令后删除自己节点的对应的过期键。

#### 2.数据库主要由dict和expires两个字典组成，其中dict字典负责保存键值对，expires字典保存键的过期时间。过期时间是一个以毫秒计算的unix时间戳。

#### 3.执行SAVE命令或BGSAVE命令所产生的新RDB文件不会包含已经过期的键，执行BGWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。当过期键被删除之后，服务器会追加一条DEL命令到现有的AOF文件末尾，显示的删除过期键。

#### 4.RDB：RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据，SAVE命令由服务器进程执行保存操作，所以该命令会阻塞服务器。BGSAVE命令由子进程执行保存操作，不会阻塞服务器。RDB文件是一个经过压缩的二进制文件，由多个部分组成，对于不同类型的键值对，RDB文件会使用不同的方式保存。

#### 5.AOF：AOF文件通过保存所有修改数据库的写命令请求，会在AOF缓冲区内保存命令，之后再定期写入并同步到AOF文件中。

在执行BGWRITEAOF命令时，Redis会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新的AOF文件期间，记录服务器执行的所有写命令，当子进程完成创建AOF文件的工作之后，服务器会将重写缓冲区中所有内容追加到新的AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致，最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF的文件重写操作。

### 四、独立功能的实现

#### 1.Redis事务：

多个命令会被入队到事务队列中，然后按照FIFO的顺序执行。

事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕后，事务才会结束。

带有WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的DIRTY_CAS标志打开。只有客户端的REDIS_DIRTY_CAS标志未被打开时，服务器才会执行客户端提交的事务，否则服务器将拒绝执行客户端提交的事务。（如果客户端的REDIS_DIRTY_CAS标志已经被打开，那么说明客户端所监视的键当中，至少有一个键已经被修改过了，在这种情况下，客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务）

Redis的事务总是具有ACID中的原子性、一致性和隔离性，当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。
